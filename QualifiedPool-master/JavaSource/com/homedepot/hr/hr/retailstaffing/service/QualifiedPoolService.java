package com.homedepot.hr.hr.retailstaffing.service;
/* 
 * This program is proprietary to The Home Depot and is not to be
 * reproduced, used, or disclosed without permission of:
 *    
 *  The Home Depot
 *  2455 Paces Ferry Road, N.W.
 *  Atlanta, GA 30339-4053
 *
 * File Name: QualifiedPoolService.java
 * Application: RetailStaffing
 */
import java.sql.Date;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

import javax.ws.rs.Consumes;
import javax.ws.rs.DefaultValue;
import javax.ws.rs.FormParam;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.MediaType;

import org.apache.log4j.Logger;

import com.google.gson.Gson;
import com.homedepot.hr.hr.retailstaffing.bl.AssociateManager;
import com.homedepot.hr.hr.retailstaffing.bl.AvailabilityManager;
import com.homedepot.hr.hr.retailstaffing.bl.ConsideredFlagManager;
import com.homedepot.hr.hr.retailstaffing.bl.QualifiedPoolManager;
import com.homedepot.hr.hr.retailstaffing.dto.QualifiedCandidate;
import com.homedepot.hr.hr.retailstaffing.dto.request.QualifiedPoolRequest;
import com.homedepot.hr.hr.retailstaffing.dto.response.ErrorDetails;
import com.homedepot.hr.hr.retailstaffing.dto.response.QualifiedPoolResponse;
import com.homedepot.hr.hr.retailstaffing.exception.QualifiedPoolException;
import com.homedepot.hr.hr.retailstaffing.interfaces.Constants;
import com.homedepot.hr.hr.retailstaffing.util.JsonHandler;
import com.homedepot.hr.hr.retailstaffing.util.QualifiedPoolMessage;
import com.homedepot.hr.hr.retailstaffing.util.XmlHandler;

/**
 * This class contains REST-style web service methods for retrieving qualified candidates
 * for employment requisitions
 * 
 * @author rlp05
 */
@Path("/qualifiedpool")
public class QualifiedPoolService
{	
	// logger instance
	private final Logger mLogger = Logger.getLogger(getClass());
	// Use Kenexa Tiering
	private static int useTiering = -1;
	
	private Gson gson=new Gson();
	
	/**
	 * This method gets qualified associates for the data provided
	 * 
	 * @param inputXml			XML/JSON containing the employment requisition number and any job skill filters
	 * 							that need to be applied. The XStream API is used to un-marshal this XML/JSON into
	 * 							a QualifiedPoolRequest object
	 * @param version			Optional parameter, can be used later to change the request/response/logic that gets
	 * 							applied. If not provided, it will be defaulted to 1.  Version 1 XML Input/Output,
	 * 							version 2 JSON Input/Output
	 * 
	 * @return					XML/JSON containing the qualified applicants for the employment requisition data provided.
	 * 							This XML/JSON is generated by using the XStream API to marshal a QualifiedPoolReqsponse object
	 */
	@POST
	@Path("/associates")
	@Consumes(MediaType.APPLICATION_FORM_URLENCODED)
	@Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML})
	public String getQualifiedAssociatesForRequisition(@FormParam("data") String inputXml, @DefaultValue("1") @QueryParam("version") int version)
	{
		// used for metrics gathering
		long startTime = 0;		
		// go ahead and initialize it, it'll be used if the request works or fails
		QualifiedPoolResponse response = new QualifiedPoolResponse();
		
		if(mLogger.isDebugEnabled())
		{
			startTime = System.currentTimeMillis();
			mLogger.debug(String.format("Entering getQualifiedAssociatesForRequisition(), inputXml: %1$s, version: %2$d", inputXml, version));
		} // end if
		
		try
		{
			// first let's validate we support the version. Version 1 and 2 supported
			if(version != 1 && version != 2)
			{
				throw new QualifiedPoolException(Constants.ERRCD_INVALID_VERSION, String.format("Unsupported version %1$d provided", version));
			} // end if(version != 1)
			
			// next convert the input XML into an object and perform validation on the data contained within the object
			QualifiedPoolRequest request = parseAndValidateRequest(inputXml, version);
			
			// now invoke the business logic method to build the associate qualified pool
			List<QualifiedCandidate> candidates = QualifiedPoolManager.getQualifiedAssociatesForRequisition(request.getRequisitionNbr(), request.getJobSkillFilters());

			// if we got candidates back, get considered flag, availability, Time in Position, and Last Review Score data
			if (candidates != null && candidates.size() > 0) {
				// next add the considered flag to associates in qualified pool
				ConsideredFlagManager.getConsideredFlagData(candidates, request.getRequisitionNbr());
			
				// next add the availability to candidates
				AvailabilityManager.getAssociateAvailability(candidates);
				
				mLogger.debug("Number Of Candidates:" + candidates.size());
				// next add time in position
				AssociateManager.getAssociatesTimeInPosition(candidates);
				
				// next add last review score
				AssociateManager.getAssociatesLastReviewScore(candidates);
			}					
			
			// if we got candidates back, sort and add them to the response
			if(candidates != null)
			{
				//Sort by Last Updated TS DESC Order.  Removed from SQL.
				Collections.sort(candidates, new Comparator<QualifiedCandidate>() {
			        @Override
			        public int compare(final QualifiedCandidate object1, final QualifiedCandidate object2) {
			        	Date i = new Date(object2.getUpdTs().getTime()); 
			        	int result = i.compareTo(new Date(object1.getUpdTs().getTime()));
			            return result;
			        }
			    });		
				
				// add them to the response
				response.setCandidates(candidates);
				// add Tiering value to the response
				response.setTiering(useTiering);
			} // end if(candidates != null)
		} // end try
		catch(QualifiedPoolException qpe)
		{
			// write a warning to APPL_LOG
			mLogger.warn(new QualifiedPoolMessage(qpe.getMessage()));
			// write the error details to the log (error so they always show up)
			mLogger.error("An exception occurred processing request", qpe);
			// populate an error details object with information about the error that occurred
			ErrorDetails errorDetails = new ErrorDetails();
			errorDetails.setErrorCode(qpe.getErrorCode());
			errorDetails.setErrorMessage(qpe.getMessage());
			// add the error details to the response
			response.setErrorDetails(errorDetails);
		} // end catch
		
		if(mLogger.isDebugEnabled())
		{
			long endTime = System.currentTimeMillis();
			mLogger.debug(String.format("Exiting getQualifiedAssociatesForRequisition(), inputXml: %1$s, version: %2$s. Total time to process request: %3$01d.%4$03d seconds", 
				inputXml, version, ((endTime - startTime) / 1000), ((endTime - startTime) % 1000)));
		} // end if
		
		String generatedOutput = "";
		if (version == 1) {
			// Marshal the response object into XML and return it
			generatedOutput = XmlHandler.toXml(response);
		} else if (version == 2) {
			// Marshal the response object into JSON and return it
			generatedOutput = JsonHandler.toJson(response);
		}
		return generatedOutput;		
	} // end function getQualifiedAssociatesForRequisition()
	
	/**
	 * This method gets qualified applicants for the data provided
	 * 
	 * @param inputXml			XML/JSON containing the employment requisition number and any job skill filters
	 * 							that need to be applied. The XStream API is used to un-marshal this XML/JSON into
	 * 							a QualifiedPoolRequest object
	 * @param version			Optional parameter, can be used later to change the request/response/logic that gets
	 * 							applied. If not provided, it will be defaulted to 1.  Version 1 XML Input/Output,
	 * 							version 2 JSON Input/Output
	 * 
	 * @return					XML/JSON containing the qualified applicants for the employment requisition data provided.
	 * 							This XML/JSON is generated by using the XStream API to marshal a QualifiedPoolReqsponse object
	 */
	@POST
	@Path("/applicants")
	@Consumes(MediaType.APPLICATION_FORM_URLENCODED)
	@Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML})
	public String getQualifiedApplicantsForRequisition(@FormParam("data") String inputXml, @DefaultValue("1") @QueryParam("version") int version)
	{
		// used for metrics gathering
		long startTime = 0;		
		// go ahead and initialize it, it'll be used if the request works or fails
		QualifiedPoolResponse response = new QualifiedPoolResponse();
		
		if(mLogger.isDebugEnabled())
		{
			startTime = System.currentTimeMillis();
			mLogger.debug(String.format("Entering getQualifiedApplicantsForRequisition(), inputXml: %1$s, version: %2$d", inputXml, version));
		} // end if
		
		try
		{
			// first let's validate we support the version. Version 1 and 2 supported
			if(version != 1 && version != 2)
			{
				throw new QualifiedPoolException(Constants.ERRCD_INVALID_VERSION, String.format("Unsupported version %1$d provided", version));
			} // end if(version != 1)
			
			// next convert the input XML into an object and perform validation on the data contained within the object
			QualifiedPoolRequest request = parseAndValidateRequest(inputXml, version);
			
			// Check to see if Tiering is active and set static variable useTiering if < 0 
			if (useTiering < 0) {
				useTiering = QualifiedPoolManager.checkTieringFlg();
			}
			if (mLogger.isDebugEnabled()) {
				mLogger.debug(String.format("Qualified Pool Applicant Tiering value: %1$d", useTiering));		
			}
			
			// now invoke the business logic method to build the applicants qualified pool
			List<QualifiedCandidate> candidates = QualifiedPoolManager.getQualifiedApplicantsForRequisition(request.getRequisitionNbr(), request.getJobSkillFilters(), useTiering);
			
			// **** ATS Project, mts1876 ****
			// if we got candidates back, get considered flag and availability data
			if (candidates != null) {
				// next add the considered flag to applicants in qualified pool
				ConsideredFlagManager.getConsideredFlagData(candidates, request.getRequisitionNbr());
			
				// next add the availability to candidates
				AvailabilityManager.getApplicantAvailability(candidates);
			}
			// **** ATS Project, mts1876 ****
			
			// if we got candidates back, add them to the response
			if(candidates != null)
			{
				// add them to the response
				response.setCandidates(candidates);
				// add Tiering value to the response
				response.setTiering(useTiering);
			} // end if(candidates != null)
		} // end try
		catch(QualifiedPoolException qpe)
		{
			// write a warning to APPL_LOG
			mLogger.warn(new QualifiedPoolMessage(qpe.getMessage()));
			// write the error details to the log (error so they always show up)
			mLogger.error("An exception occurred processing request", qpe);
			// populate an error details object with information about the error that occurred
			ErrorDetails errorDetails = new ErrorDetails();
			errorDetails.setErrorCode(qpe.getErrorCode());
			errorDetails.setErrorMessage(qpe.getMessage());
			// add the error details to the response
			response.setErrorDetails(errorDetails);
		} // end catch
		
		if(mLogger.isDebugEnabled())
		{
			long endTime = System.currentTimeMillis();
			mLogger.debug(String.format("Exiting getQualifiedApplicantsForRequisition(), inputXml: %1$s, version: %2$s. Total time to process request: %3$01d.%4$03d seconds", 
				inputXml, version, ((endTime - startTime) / 1000), ((endTime - startTime) % 1000)));
		} // end if
		
		String generatedOutput = "";
		if (version == 1) {
			// Marshal the response object into XML and return it
			generatedOutput = XmlHandler.toXml(response);
		} else if (version == 2) {
			// Marshal the response object into JSON and return it
			generatedOutput = JsonHandler.toJson(response);
		}
		return generatedOutput;
	} // end function getQualifiedApplicantsForRequisition()
	
	/*
	 * This method validates the input XML/JSON and uses the XStream API to un-marshal it into a QualifiedPoolRequest
	 * object
	 *  
	 * @param inputXml						The XML to validate/marshal or JSON
	 * @param version						Version number, used to change the validation, type of objects that get
	 * 										generated during marshalling, etc.  Version 1 XML, version 2 JSON
	 * 
	 * @return								QualifiedPoolRequest object generated using the inputXML/JSON
	 * 
	 * @throws QualifiedPoolException		Thrown if any of the following occur:
	 * 										<ul>
	 * 											<li>The input XML provided is null or empty</li>
	 * 											<li>An exception occurs marshalling the XML/JSON into an object (data type mismatch, etc.)</li>
	 * 											<li>The requisition number from the input XML/JSON is &lt; 0</li>
	 * 											<li>The XML contained job skill filters AND any of the filters are &lt; 0</li>								
	 * 										</ul>
	 */
	private QualifiedPoolRequest parseAndValidateRequest(String inputXml, int version) throws QualifiedPoolException
	{
		QualifiedPoolRequest request = null;
		
		if(mLogger.isDebugEnabled())
		{
			mLogger.debug(String.format("Entering parseAndValidateRequest(), inputXml = %1$s, version = %2$d", inputXml, version));
		} // end if
		
		// before we attempt to parse let's make sure the input XML is not null or empty
		if(inputXml == null || inputXml.trim().length() == 0)
		{
			// throw a new exception (will be logged by the calling function)
			throw new QualifiedPoolException(Constants.ERRCD_INVALID_REQUEST, String.format("%1$s input xml was provided", (inputXml == null ? "Null" : "Empty")));
		} // end if(inputXml == null || inputXml.trim().length() == 0)
		
		try
		{
			// parse the input XML into a request object
			if (version == 1) {
				request = (QualifiedPoolRequest)XmlHandler.fromXml(inputXml);
				mLogger.debug("QualifiedPoolRequest object created from XML");
			} else if (version == 2) {
				// parse the input JSON into a request object
				request = (QualifiedPoolRequest)JsonHandler.fromJson(inputXml);
				mLogger.debug("QualifiedPoolRequest object created");
			}
		} // end try
		catch(Exception e)
		{
			// this exception could be thrown if there was a data mismatch, a missing element, etc.
			throw new QualifiedPoolException(Constants.ERRCD_INVALID_REQUEST, e);
		} // end catch
		
		// next validate the requisition number provided in the request is valid
		if(request.getRequisitionNbr() < 1)
		{
			throw new QualifiedPoolException(Constants.ERRCD_INVALID_REQNBR, String.format("Invalid requisition number %1$d provided", request.getRequisitionNbr()));
		} // end if(request.getRequisitionNbr() < 1)
		mLogger.debug("Requisition number validated");
		
		// if there were job skill filters provided 
		if(request.getJobSkillFilters() != null && request.getJobSkillFilters().size() > 0)
		{
			// iterate all the filters
			for(short jobSkillFilter : request.getJobSkillFilters())
			{
				// validate they are > 0
				if(jobSkillFilter < 1)
				{
					throw new QualifiedPoolException(Constants.ERRCD_INVALID_JOBSKILL, String.format("Invalid job skill filter %1$d provided", jobSkillFilter));
				} // end if(jobSkillFilter < 1)
			} // end for(short jobSkillFilter : request.getJobSkillFilters())

			mLogger.debug("Job skill filters validated");
		} // end if(request.getJobSkillFilters() != null && request.getJobSkillFilters().size() > 0)
		
		if(mLogger.isDebugEnabled())
		{
			mLogger.debug(String.format("Exiting parseAndValidateRequest(), inputXml = %1$s, version = %2$d", inputXml, version));
		} // end if		
		
		return request;
	} // end function parseAndValidationRequest()
} // end class QualifiedPoolService